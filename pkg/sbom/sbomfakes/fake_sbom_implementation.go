// Code generated by counterfeiter. DO NOT EDIT.
package sbomfakes

import (
	"io/fs"
	"sync"

	"chainguard.dev/apko/pkg/sbom/generator"
	"chainguard.dev/apko/pkg/sbom/options"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"gitlab.alpinelinux.org/alpine/go/repository"
)

type FakeSbomImplementation struct {
	CheckGeneratorsStub        func(*options.Options, map[string]generator.Generator) error
	checkGeneratorsMutex       sync.RWMutex
	checkGeneratorsArgsForCall []struct {
		arg1 *options.Options
		arg2 map[string]generator.Generator
	}
	checkGeneratorsReturns struct {
		result1 error
	}
	checkGeneratorsReturnsOnCall map[int]struct {
		result1 error
	}
	GenerateStub        func(*options.Options, map[string]generator.Generator) ([]string, error)
	generateMutex       sync.RWMutex
	generateArgsForCall []struct {
		arg1 *options.Options
		arg2 map[string]generator.Generator
	}
	generateReturns struct {
		result1 []string
		result2 error
	}
	generateReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GenerateIndexStub        func(*options.Options, map[string]generator.Generator) ([]string, error)
	generateIndexMutex       sync.RWMutex
	generateIndexArgsForCall []struct {
		arg1 *options.Options
		arg2 map[string]generator.Generator
	}
	generateIndexReturns struct {
		result1 []string
		result2 error
	}
	generateIndexReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	ReadPackageIndexStub        func(fs.FS, *options.Options, string) ([]*repository.Package, error)
	readPackageIndexMutex       sync.RWMutex
	readPackageIndexArgsForCall []struct {
		arg1 fs.FS
		arg2 *options.Options
		arg3 string
	}
	readPackageIndexReturns struct {
		result1 []*repository.Package
		result2 error
	}
	readPackageIndexReturnsOnCall map[int]struct {
		result1 []*repository.Package
		result2 error
	}
	ReadReleaseDataStub        func(fs.FS, *options.Options, string) error
	readReleaseDataMutex       sync.RWMutex
	readReleaseDataArgsForCall []struct {
		arg1 fs.FS
		arg2 *options.Options
		arg3 string
	}
	readReleaseDataReturns struct {
		result1 error
	}
	readReleaseDataReturnsOnCall map[int]struct {
		result1 error
	}
	SetLayerDigestStub        func(*options.Options, v1.Hash) error
	setLayerDigestMutex       sync.RWMutex
	setLayerDigestArgsForCall []struct {
		arg1 *options.Options
		arg2 v1.Hash
	}
	setLayerDigestReturns struct {
		result1 error
	}
	setLayerDigestReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSbomImplementation) CheckGenerators(arg1 *options.Options, arg2 map[string]generator.Generator) error {
	fake.checkGeneratorsMutex.Lock()
	ret, specificReturn := fake.checkGeneratorsReturnsOnCall[len(fake.checkGeneratorsArgsForCall)]
	fake.checkGeneratorsArgsForCall = append(fake.checkGeneratorsArgsForCall, struct {
		arg1 *options.Options
		arg2 map[string]generator.Generator
	}{arg1, arg2})
	stub := fake.CheckGeneratorsStub
	fakeReturns := fake.checkGeneratorsReturns
	fake.recordInvocation("CheckGenerators", []interface{}{arg1, arg2})
	fake.checkGeneratorsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSbomImplementation) CheckGeneratorsCallCount() int {
	fake.checkGeneratorsMutex.RLock()
	defer fake.checkGeneratorsMutex.RUnlock()
	return len(fake.checkGeneratorsArgsForCall)
}

func (fake *FakeSbomImplementation) CheckGeneratorsCalls(stub func(*options.Options, map[string]generator.Generator) error) {
	fake.checkGeneratorsMutex.Lock()
	defer fake.checkGeneratorsMutex.Unlock()
	fake.CheckGeneratorsStub = stub
}

func (fake *FakeSbomImplementation) CheckGeneratorsArgsForCall(i int) (*options.Options, map[string]generator.Generator) {
	fake.checkGeneratorsMutex.RLock()
	defer fake.checkGeneratorsMutex.RUnlock()
	argsForCall := fake.checkGeneratorsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSbomImplementation) CheckGeneratorsReturns(result1 error) {
	fake.checkGeneratorsMutex.Lock()
	defer fake.checkGeneratorsMutex.Unlock()
	fake.CheckGeneratorsStub = nil
	fake.checkGeneratorsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSbomImplementation) CheckGeneratorsReturnsOnCall(i int, result1 error) {
	fake.checkGeneratorsMutex.Lock()
	defer fake.checkGeneratorsMutex.Unlock()
	fake.CheckGeneratorsStub = nil
	if fake.checkGeneratorsReturnsOnCall == nil {
		fake.checkGeneratorsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkGeneratorsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSbomImplementation) Generate(arg1 *options.Options, arg2 map[string]generator.Generator) ([]string, error) {
	fake.generateMutex.Lock()
	ret, specificReturn := fake.generateReturnsOnCall[len(fake.generateArgsForCall)]
	fake.generateArgsForCall = append(fake.generateArgsForCall, struct {
		arg1 *options.Options
		arg2 map[string]generator.Generator
	}{arg1, arg2})
	stub := fake.GenerateStub
	fakeReturns := fake.generateReturns
	fake.recordInvocation("Generate", []interface{}{arg1, arg2})
	fake.generateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSbomImplementation) GenerateCallCount() int {
	fake.generateMutex.RLock()
	defer fake.generateMutex.RUnlock()
	return len(fake.generateArgsForCall)
}

func (fake *FakeSbomImplementation) GenerateCalls(stub func(*options.Options, map[string]generator.Generator) ([]string, error)) {
	fake.generateMutex.Lock()
	defer fake.generateMutex.Unlock()
	fake.GenerateStub = stub
}

func (fake *FakeSbomImplementation) GenerateArgsForCall(i int) (*options.Options, map[string]generator.Generator) {
	fake.generateMutex.RLock()
	defer fake.generateMutex.RUnlock()
	argsForCall := fake.generateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSbomImplementation) GenerateReturns(result1 []string, result2 error) {
	fake.generateMutex.Lock()
	defer fake.generateMutex.Unlock()
	fake.GenerateStub = nil
	fake.generateReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeSbomImplementation) GenerateReturnsOnCall(i int, result1 []string, result2 error) {
	fake.generateMutex.Lock()
	defer fake.generateMutex.Unlock()
	fake.GenerateStub = nil
	if fake.generateReturnsOnCall == nil {
		fake.generateReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.generateReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeSbomImplementation) GenerateIndex(arg1 *options.Options, arg2 map[string]generator.Generator) ([]string, error) {
	fake.generateIndexMutex.Lock()
	ret, specificReturn := fake.generateIndexReturnsOnCall[len(fake.generateIndexArgsForCall)]
	fake.generateIndexArgsForCall = append(fake.generateIndexArgsForCall, struct {
		arg1 *options.Options
		arg2 map[string]generator.Generator
	}{arg1, arg2})
	stub := fake.GenerateIndexStub
	fakeReturns := fake.generateIndexReturns
	fake.recordInvocation("GenerateIndex", []interface{}{arg1, arg2})
	fake.generateIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSbomImplementation) GenerateIndexCallCount() int {
	fake.generateIndexMutex.RLock()
	defer fake.generateIndexMutex.RUnlock()
	return len(fake.generateIndexArgsForCall)
}

func (fake *FakeSbomImplementation) GenerateIndexCalls(stub func(*options.Options, map[string]generator.Generator) ([]string, error)) {
	fake.generateIndexMutex.Lock()
	defer fake.generateIndexMutex.Unlock()
	fake.GenerateIndexStub = stub
}

func (fake *FakeSbomImplementation) GenerateIndexArgsForCall(i int) (*options.Options, map[string]generator.Generator) {
	fake.generateIndexMutex.RLock()
	defer fake.generateIndexMutex.RUnlock()
	argsForCall := fake.generateIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSbomImplementation) GenerateIndexReturns(result1 []string, result2 error) {
	fake.generateIndexMutex.Lock()
	defer fake.generateIndexMutex.Unlock()
	fake.GenerateIndexStub = nil
	fake.generateIndexReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeSbomImplementation) GenerateIndexReturnsOnCall(i int, result1 []string, result2 error) {
	fake.generateIndexMutex.Lock()
	defer fake.generateIndexMutex.Unlock()
	fake.GenerateIndexStub = nil
	if fake.generateIndexReturnsOnCall == nil {
		fake.generateIndexReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.generateIndexReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeSbomImplementation) ReadPackageIndex(arg1 fs.FS, arg2 *options.Options, arg3 string) ([]*repository.Package, error) {
	fake.readPackageIndexMutex.Lock()
	ret, specificReturn := fake.readPackageIndexReturnsOnCall[len(fake.readPackageIndexArgsForCall)]
	fake.readPackageIndexArgsForCall = append(fake.readPackageIndexArgsForCall, struct {
		arg1 fs.FS
		arg2 *options.Options
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ReadPackageIndexStub
	fakeReturns := fake.readPackageIndexReturns
	fake.recordInvocation("ReadPackageIndex", []interface{}{arg1, arg2, arg3})
	fake.readPackageIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSbomImplementation) ReadPackageIndexCallCount() int {
	fake.readPackageIndexMutex.RLock()
	defer fake.readPackageIndexMutex.RUnlock()
	return len(fake.readPackageIndexArgsForCall)
}

func (fake *FakeSbomImplementation) ReadPackageIndexCalls(stub func(fs.FS, *options.Options, string) ([]*repository.Package, error)) {
	fake.readPackageIndexMutex.Lock()
	defer fake.readPackageIndexMutex.Unlock()
	fake.ReadPackageIndexStub = stub
}

func (fake *FakeSbomImplementation) ReadPackageIndexArgsForCall(i int) (fs.FS, *options.Options, string) {
	fake.readPackageIndexMutex.RLock()
	defer fake.readPackageIndexMutex.RUnlock()
	argsForCall := fake.readPackageIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSbomImplementation) ReadPackageIndexReturns(result1 []*repository.Package, result2 error) {
	fake.readPackageIndexMutex.Lock()
	defer fake.readPackageIndexMutex.Unlock()
	fake.ReadPackageIndexStub = nil
	fake.readPackageIndexReturns = struct {
		result1 []*repository.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeSbomImplementation) ReadPackageIndexReturnsOnCall(i int, result1 []*repository.Package, result2 error) {
	fake.readPackageIndexMutex.Lock()
	defer fake.readPackageIndexMutex.Unlock()
	fake.ReadPackageIndexStub = nil
	if fake.readPackageIndexReturnsOnCall == nil {
		fake.readPackageIndexReturnsOnCall = make(map[int]struct {
			result1 []*repository.Package
			result2 error
		})
	}
	fake.readPackageIndexReturnsOnCall[i] = struct {
		result1 []*repository.Package
		result2 error
	}{result1, result2}
}

func (fake *FakeSbomImplementation) ReadReleaseData(arg1 fs.FS, arg2 *options.Options, arg3 string) error {
	fake.readReleaseDataMutex.Lock()
	ret, specificReturn := fake.readReleaseDataReturnsOnCall[len(fake.readReleaseDataArgsForCall)]
	fake.readReleaseDataArgsForCall = append(fake.readReleaseDataArgsForCall, struct {
		arg1 fs.FS
		arg2 *options.Options
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ReadReleaseDataStub
	fakeReturns := fake.readReleaseDataReturns
	fake.recordInvocation("ReadReleaseData", []interface{}{arg1, arg2, arg3})
	fake.readReleaseDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSbomImplementation) ReadReleaseDataCallCount() int {
	fake.readReleaseDataMutex.RLock()
	defer fake.readReleaseDataMutex.RUnlock()
	return len(fake.readReleaseDataArgsForCall)
}

func (fake *FakeSbomImplementation) ReadReleaseDataCalls(stub func(fs.FS, *options.Options, string) error) {
	fake.readReleaseDataMutex.Lock()
	defer fake.readReleaseDataMutex.Unlock()
	fake.ReadReleaseDataStub = stub
}

func (fake *FakeSbomImplementation) ReadReleaseDataArgsForCall(i int) (fs.FS, *options.Options, string) {
	fake.readReleaseDataMutex.RLock()
	defer fake.readReleaseDataMutex.RUnlock()
	argsForCall := fake.readReleaseDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSbomImplementation) ReadReleaseDataReturns(result1 error) {
	fake.readReleaseDataMutex.Lock()
	defer fake.readReleaseDataMutex.Unlock()
	fake.ReadReleaseDataStub = nil
	fake.readReleaseDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSbomImplementation) ReadReleaseDataReturnsOnCall(i int, result1 error) {
	fake.readReleaseDataMutex.Lock()
	defer fake.readReleaseDataMutex.Unlock()
	fake.ReadReleaseDataStub = nil
	if fake.readReleaseDataReturnsOnCall == nil {
		fake.readReleaseDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.readReleaseDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSbomImplementation) SetLayerDigest(arg1 *options.Options, arg2 v1.Hash) error {
	fake.setLayerDigestMutex.Lock()
	ret, specificReturn := fake.setLayerDigestReturnsOnCall[len(fake.setLayerDigestArgsForCall)]
	fake.setLayerDigestArgsForCall = append(fake.setLayerDigestArgsForCall, struct {
		arg1 *options.Options
		arg2 v1.Hash
	}{arg1, arg2})
	stub := fake.SetLayerDigestStub
	fakeReturns := fake.setLayerDigestReturns
	fake.recordInvocation("SetLayerDigest", []interface{}{arg1, arg2})
	fake.setLayerDigestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSbomImplementation) SetLayerDigestCallCount() int {
	fake.setLayerDigestMutex.RLock()
	defer fake.setLayerDigestMutex.RUnlock()
	return len(fake.setLayerDigestArgsForCall)
}

func (fake *FakeSbomImplementation) SetLayerDigestCalls(stub func(*options.Options, v1.Hash) error) {
	fake.setLayerDigestMutex.Lock()
	defer fake.setLayerDigestMutex.Unlock()
	fake.SetLayerDigestStub = stub
}

func (fake *FakeSbomImplementation) SetLayerDigestArgsForCall(i int) (*options.Options, v1.Hash) {
	fake.setLayerDigestMutex.RLock()
	defer fake.setLayerDigestMutex.RUnlock()
	argsForCall := fake.setLayerDigestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSbomImplementation) SetLayerDigestReturns(result1 error) {
	fake.setLayerDigestMutex.Lock()
	defer fake.setLayerDigestMutex.Unlock()
	fake.SetLayerDigestStub = nil
	fake.setLayerDigestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSbomImplementation) SetLayerDigestReturnsOnCall(i int, result1 error) {
	fake.setLayerDigestMutex.Lock()
	defer fake.setLayerDigestMutex.Unlock()
	fake.SetLayerDigestStub = nil
	if fake.setLayerDigestReturnsOnCall == nil {
		fake.setLayerDigestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setLayerDigestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSbomImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkGeneratorsMutex.RLock()
	defer fake.checkGeneratorsMutex.RUnlock()
	fake.generateMutex.RLock()
	defer fake.generateMutex.RUnlock()
	fake.generateIndexMutex.RLock()
	defer fake.generateIndexMutex.RUnlock()
	fake.readPackageIndexMutex.RLock()
	defer fake.readPackageIndexMutex.RUnlock()
	fake.readReleaseDataMutex.RLock()
	defer fake.readReleaseDataMutex.RUnlock()
	fake.setLayerDigestMutex.RLock()
	defer fake.setLayerDigestMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSbomImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
